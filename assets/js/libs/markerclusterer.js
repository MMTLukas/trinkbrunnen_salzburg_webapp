/*eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('5 J(b,a){b.18().V(J,o.n.32);4.G=b;4.2F=b.18().2r();4.P=a;4.B=s;4.q=s;4.X=s;4.1j=t;4.L(b.z())}J.6.2E=5(){7 d=4;7 g;7 f;4.q=3C.3x("2a");4.q.5m=4.2F;9(4.1j){4.27()}4.4I().4F.4A(4.q);o.n.v.1L(4.z(),"4i",5(){f=g});o.n.v.1E(4.q,"44",5(){g=K;f=t});o.n.v.1E(4.q,"2N",5(e){g=t;9(!f){7 c;7 b;7 a=d.G.18();o.n.v.W(a,"2N",d.G);o.n.v.W(a,"40",d.G);9(a.2C()){b=a.1v();c=d.G.1x();a.z().1V(c);1O(5(){a.z().1V(c);9(b!==s&&(a.z().1a()>b)){a.z().3O(b+1)}},3F)}e.3B=K;9(e.2n){e.2n()}}});o.n.v.1E(4.q,"2f",5(){7 a=d.G.18();o.n.v.W(a,"2f",d.G)});o.n.v.1E(4.q,"2B",5(){7 a=d.G.18();o.n.v.W(a,"2B",d.G)})};J.6.2G=5(){9(4.q&&4.q.2T){4.1N();o.n.v.5d(4.q);4.q.2T.55(4.q);4.q=s}};J.6.3f=5(){9(4.1j){7 a=4.28(4.B);4.q.13.1F=a.y+"A";4.q.13.1M=a.x+"A"}};J.6.1N=5(){9(4.q){4.q.13.38="2W"}4.1j=t};J.6.27=5(){9(4.q){7 a=4.28(4.B);4.q.13.4r=4.2V(a);9(4.G.12){4.q.2S="<4d 4a=\'"+4.2c+"\'><2a 13=\'21: 2Q; 1F: 2P; 1M: 2P; 1c: "+4.Z+"A;\'>"+4.X.1d+"</2a>"}C{4.q.2S=4.X.1d}9(1o 4.X.15==="1f"||4.X.15===""){4.q.15=4.G.18().2K()}C{4.q.15=4.X.15}4.q.13.38=""}4.1j=K};J.6.2I=5(a){4.X=a;7 b=w.3Y(0,a.2D-1);b=w.1X(4.P.p-1,b);7 c=4.P[b];4.2c=c.1W;4.Q=c.14;4.Z=c.1c;4.I=c.3T;4.1P=c.3Q||[1Q(4.Q/2,10),1Q(4.Z/2,10)];4.2l=c.3H||"3E";4.2i=c.3A||11;4.2h=c.3z||"2W";4.2g=c.3w||"3u";4.2A=c.3r||"3o";4.2U=c.3l||"5l,5h-5c";4.3j=c.54||"0 0"};J.6.3g=5(a){4.B=a};J.6.2V=5(b){7 a=[];9(!4.G.12){a.F(\'3e-4S:1W(\'+4.2c+\');\');a.F(\'3e-21:\'+4.3j+\';\')}9(1o 4.I===\'4P\'){9(1o 4.I[0]===\'3b\'&&4.I[0]>0&&4.I[0]<4.Q){a.F(\'14:\'+(4.Q-4.I[0])+\'A; 3a-1F:\'+4.I[0]+\'A;\')}C{a.F(\'14:\'+4.Q+\'A; 37-14:\'+4.Q+\'A;\')}9(1o 4.I[1]===\'3b\'&&4.I[1]>0&&4.I[1]<4.Z){a.F(\'1c:\'+(4.Z-4.I[1])+\'A; 3a-1M:\'+4.I[1]+\'A;\')}C{a.F(\'1c:\'+4.Z+\'A; 1d-35:1e;\')}}C{a.F(\'14:\'+4.Q+\'A; 37-14:\'+4.Q+\'A; 1c:\'+4.Z+\'A; 1d-35:1e;\')}a.F(\'4G:4E; 1F:\'+b.y+\'A; 1M:\'+b.x+\'A; 4C:\'+4.2l+\'; 21:2Q; 1I-1q:\'+4.2i+\'A; 1I-4z:\'+4.2U+\'; 1I-4y:\'+4.2g+\'; 1I-13:\'+4.2A+\'; 1d-4x:\'+4.2h+\';\');j a.4v("")};J.6.28=5(b){7 a=4.3d().22(b);a.x-=4.1P[1];a.y-=4.1P[0];j a};5 E(a){4.17=a;4.O=a.z();4.T=a.3h();4.Y=a.2R();4.1g=a.3k();4.12=a.3i();4.k=[];4.B=s;4.2b=s;4.16=H J(4,a.20())}E.6.41=5(){j 4.k.p};E.6.1D=5(){j 4.k};E.6.2O=5(){j 4.B};E.6.z=5(){j 4.O};E.6.18=5(){j 4.17};E.6.1x=5(){7 i;7 b=H o.n.1p(4.B,4.B);7 a=4.1D();u(i=0;i<a.p;i++){b.V(a[i].S())}j b};E.6.1C=5(){4.16.L(s);4.k=[];1Z 4.k};E.6.1B=5(e){7 i;7 c;7 b;9(4.2M(e)){j t}9(!4.B){4.B=e.S();4.1Y()}C{9(4.1g){7 l=4.k.p+1;7 a=(4.B.U()*(l-1)+e.S().U())/l;7 d=(4.B.19()*(l-1)+e.S().19())/l;4.B=H o.n.1n(a,d);4.1Y()}}e.1m=K;4.k.F(e);c=4.k.p;b=4.17.1v();9(b!==s&&4.O.1a()>b){9(e.z()!==4.O){e.L(4.O)}}C 9(c<4.Y){9(e.z()!==4.O){e.L(4.O)}}C 9(c===4.Y){u(i=0;i<c;i++){4.k[i].L(s)}}C{e.L(s)}4.2L();j K};E.6.2J=5(a){j 4.2b.34(a.S())};E.6.1Y=5(){7 a=H o.n.1p(4.B,4.B);4.2b=4.17.2e(a)};E.6.2L=5(){7 c=4.k.p;7 a=4.17.1v();9(a!==s&&4.O.1a()>a){4.16.1N();j}9(c<4.Y){4.16.1N();j}7 b=4.17.20().p;7 d=4.17.36()(4.k,b);4.16.3g(4.B);4.16.2I(d);4.16.27()};E.6.2M=5(a){7 i;9(4.k.1l){j 4.k.1l(a)!==-1}C{u(i=0;i<4.k.p;i++){9(a===4.k[i]){j K}}}j t};5 8(a,c,b){4.V(8,o.n.32);c=c||[];b=b||{};4.k=[];4.D=[];4.1r=[];4.1A=s;4.1s=t;4.T=b.3X||3W;4.Y=b.3V||2;4.1R=b.2z||s;4.P=b.3U||[];4.29=b.15||"";4.1K=K;9(b.2y!==1f){4.1K=b.2y}4.1g=t;9(b.2x!==1f){4.1g=b.2x}4.1b=t;9(b.2v!==1f){4.1b=b.2v}4.12=t;9(b.2u!==1f){4.12=b.2u}4.1z=b.3S||8.2s;4.1u=b.3R||8.2p;4.1t=b.3P||8.2o;4.1U=b.3J||8.2m;4.1S=b.3I||8.2k;4.1y=b.3G||8.2j;4.1T=b.3D||"N";9(3K.3L.3M().1l("3N")!==-1){4.1S=4.1y}4.2H();4.2w(c,K);4.L(a)}8.6.2E=5(){7 a=4;4.1A=4.z();4.1s=K;4.1h();4.1r=[o.n.v.1L(4.z(),"3y",5(){a.1w(t);9(4.1a()===(4.2q("3v")||0)||4.1a()===4.2q("2z")){o.n.v.W(4,"2t")}}),o.n.v.1L(4.z(),"2t",5(){a.1k()})]};8.6.2G=5(){7 i;u(i=0;i<4.k.p;i++){4.k[i].L(4.1A)}u(i=0;i<4.D.p;i++){4.D[i].1C()}4.D=[];u(i=0;i<4.1r.p;i++){o.n.v.3t(4.1r[i])}4.1r=[];4.1A=s;4.1s=t};8.6.3f=5(){};8.6.2H=5(){7 i,1q;9(4.P.p>0){j}u(i=0;i<4.1t.p;i++){1q=4.1t[i];4.P.F({1W:4.1z+(i+1)+"."+4.1u,14:1q,1c:1q})}};8.6.3s=5(){7 i;7 a=4.1D();7 b=H o.n.1p();u(i=0;i<a.p;i++){b.V(a[i].S())}4.z().1V(b)};8.6.3h=5(){j 4.T};8.6.3Z=5(a){4.T=a};8.6.2R=5(){j 4.Y};8.6.3q=5(a){4.Y=a};8.6.1v=5(){j 4.1R};8.6.3p=5(a){4.1R=a};8.6.20=5(){j 4.P};8.6.42=5(a){4.P=a};8.6.2K=5(){j 4.29};8.6.43=5(a){4.29=a};8.6.2C=5(){j 4.1K};8.6.3n=5(a){4.1K=a};8.6.3k=5(){j 4.1g};8.6.3m=5(a){4.1g=a};8.6.46=5(){j 4.1b};8.6.47=5(a){4.1b=a};8.6.5k=5(){j 4.1u};8.6.5i=5(a){4.1u=a};8.6.5g=5(){j 4.1z};8.6.5f=5(a){4.1z=a};8.6.5b=5(){j 4.1t};8.6.5a=5(a){4.1t=a};8.6.36=5(){j 4.1U};8.6.59=5(a){4.1U=a};8.6.3i=5(){j 4.12};8.6.57=5(a){4.12=a};8.6.51=5(){j 4.1y};8.6.50=5(a){4.1y=a};8.6.2r=5(){j 4.1T};8.6.4Z=5(a){4.1T=a};8.6.1D=5(){j 4.k};8.6.4X=5(){j 4.k.p};8.6.4V=5(){j 4.D};8.6.4U=5(){j 4.D.p};8.6.1B=5(b,a){4.2d(b);9(!a){4.1k()}};8.6.2w=5(b,a){7 i;u(i=0;i<b.p;i++){4.2d(b[i])}9(!a){4.1k()}};8.6.2d=5(b){9(b.4T()){7 a=4;o.n.v.1L(b,"4R",5(){9(a.1s){4.1m=t;a.1h()}})}b.1m=t;4.k.F(b)};8.6.4Q=5(c,a){7 b=4.26(c);9(!a&&b){4.1h()}j b};8.6.4O=5(a,c){7 i,r;7 b=t;u(i=0;i<a.p;i++){r=4.26(a[i]);b=b||r}9(!c&&b){4.1h()}j b};8.6.26=5(b){7 i;7 a=-1;9(4.k.1l){a=4.k.1l(b)}C{u(i=0;i<4.k.p;i++){9(b===4.k[i]){a=i;4N}}}9(a===-1){j t}b.L(s);4.k.4K(a,1);j K};8.6.4J=5(){4.1w(K);4.k=[]};8.6.1h=5(){7 a=4.D.4H();4.D=[];4.1w(t);4.1k();1O(5(){7 i;u(i=0;i<a.p;i++){a[i].1C()}},0)};8.6.2e=5(d){7 f=4.3d();7 c=H o.n.1n(d.23().U(),d.23().19());7 a=H o.n.1n(d.24().U(),d.24().19());7 e=f.22(c);e.x+=4.T;e.y-=4.T;7 g=f.22(a);g.x-=4.T;g.y+=4.T;7 b=f.2X(e);7 h=f.2X(g);d.V(b);d.V(h);j d};8.6.1k=5(){4.25(0)};8.6.1w=5(a){7 i,M;u(i=0;i<4.D.p;i++){4.D[i].1C()}4.D=[];u(i=0;i<4.k.p;i++){M=4.k[i];M.1m=t;9(a){M.L(s)}}};8.6.33=5(b,e){7 R=4D;7 g=(e.U()-b.U())*w.1H/1G;7 f=(e.19()-b.19())*w.1H/1G;7 a=w.1J(g/2)*w.1J(g/2)+w.31(b.U()*w.1H/1G)*w.31(e.U()*w.1H/1G)*w.1J(f/2)*w.1J(f/2);7 c=2*w.4B(w.30(a),w.30(1-a));7 d=R*c;j d};8.6.2Z=5(b,a){j a.34(b.S())};8.6.39=5(c){7 i,d,N,1e;7 a=4L;7 b=s;u(i=0;i<4.D.p;i++){N=4.D[i];1e=N.2O();9(1e){d=4.33(1e,c.S());9(d<a){a=d;b=N}}}9(b&&b.2J(c)){b.1B(c)}C{N=H E(4);N.1B(c);4.D.F(N)}};8.6.25=5(e){7 i,M;7 d;7 c=4;9(!4.1s){j}9(e===0){o.n.v.W(4,"4M",4);9(1o 4.1i!=="1f"){4w(4.1i);1Z 4.1i}}9(4.z().1a()>3){d=H o.n.1p(4.z().1x().24(),4.z().1x().23())}C{d=H o.n.1p(H o.n.1n(3c.4u,-2Y.4t),H o.n.1n(-3c.4s,2Y.4q))}7 a=4.2e(d);7 b=w.1X(e+4.1S,4.k.p);u(i=e;i<b;i++){M=4.k[i];9(!M.1m&&4.2Z(M,a)){9(!4.1b||(4.1b&&M.4W())){4.39(M)}}}9(b<4.k.p){4.1i=1O(5(){c.25(b)},0)}C{1Z 4.1i;o.n.v.W(4,"4p",4)}};8.6.V=5(d,c){j(5(b){7 a;u(a 4Y b.6){4.6[a]=b.6[a]}j 4}).4o(d,[c])};8.2m=5(a,c){7 f=0;7 b="";7 d=a.p.4n();7 e=d;4m(e!==0){e=1Q(e/10,10);f++}f=w.1X(f,c);j{1d:d,2D:f,15:b}};8.2k=52;8.2j=4l;8.2s="4k://o-n-4j-58-4h.4g.4f/4e/4c/5e/4b/m";8.2p="49";8.2o=[53,56,5j,48,45];',62,333,'||||this|function|prototype|var|MarkerClusterer|if||||||||||return|markers_|||maps|google|length|div_||null|false|for|event|Math|||getMap|px|center_|else|clusters_|Cluster|push|cluster_|new|anchor_|ClusterIcon|true|setMap|marker|cluster|map_|styles_|height_||getPosition|gridSize_|lat|extend|trigger|sums_|minClusterSize_|width_|||printable_|style|height|title|clusterIcon_|markerClusterer_|getMarkerClusterer|lng|getZoom|ignoreHidden_|width|text|center|undefined|averageCenter_|repaint|timerRefStatic|visible_|redraw_|indexOf|isAdded|LatLng|typeof|LatLngBounds|size|listeners_|ready_|imageSizes_|imageExtension_|getMaxZoom|resetViewport_|getBounds|batchSizeIE_|imagePath_|activeMap_|addMarker|remove|getMarkers|addDomListener|top|180|PI|font|sin|zoomOnClick_|addListener|left|hide|setTimeout|anchorIcon_|parseInt|maxZoom_|batchSize_|clusterClass_|calculator_|fitBounds|url|min|calculateBounds_|delete|getStyles|position|fromLatLngToDivPixel|getNorthEast|getSouthWest|createClusters_|removeMarker_|show|getPosFromLatLng_|title_|div|bounds_|url_|pushMarkerTo_|getExtendedBounds|mouseover|fontWeight_|textDecoration_|textSize_|BATCH_SIZE_IE|BATCH_SIZE|textColor_|CALCULATOR|stopPropagation|IMAGE_SIZES|IMAGE_EXTENSION|get|getClusterClass|IMAGE_PATH|idle|printable|ignoreHidden|addMarkers|averageCenter|zoomOnClick|maxZoom|fontStyle_|mouseout|getZoomOnClick|index|onAdd|className_|onRemove|setupStyles_|useStyle|isMarkerInClusterBounds|getTitle|updateIcon_|isMarkerAlreadyAdded_|click|getCenter|0px|absolute|getMinimumClusterSize|innerHTML|parentNode|fontFamily_|createCss|none|fromDivPixelToLatLng|178|isMarkerInBounds_|sqrt|cos|OverlayView|distanceBetweenPoints_|contains|align|getCalculator|line|display|addToClosestCluster_|padding|number|85|getProjection|background|draw|setCenter|getGridSize|getPrintable|backgroundPosition_|getAverageCenter|fontFamily|setAverageCenter|setZoomOnClick|normal|setMaxZoom|setMinimumClusterSize|fontStyle|fitMapToMarkers|removeListener|bold|minZoom|fontWeight|createElement|zoom_changed|textDecoration|textSize|cancelBubble|document|clusterClass|black|100|batchSizeIE|textColor|batchSize|calculator|navigator|userAgent|toLowerCase|msie|setZoom|imageSizes|anchorIcon|imageExtension|imagePath|anchor|styles|minimumClusterSize|60|gridSize|max|setGridSize|clusterclick|getSize|setStyles|setTitle|mousedown|90|getIgnoreHidden|setIgnoreHidden|78|png|src|images|trunk|img|svn|com|googlecode|v3|bounds_changed|utility|http|500|while|toString|apply|clusteringend|00048865625|cssText|08136444384544|48388434375|02070771743472|join|clearTimeout|decoration|weight|family|appendChild|atan2|color|6371|pointer|overlayMouseTarget|cursor|slice|getPanes|clearMarkers|splice|40000|clusteringbegin|break|removeMarkers|object|removeMarker|dragend|image|getDraggable|getTotalClusters|getClusters|getVisible|getTotalMarkers|in|setClusterClass|setBatchSizeIE|getBatchSizeIE|2000||backgroundPosition|removeChild||setPrintable|library|setCalculator|setImageSizes|getImageSizes|serif|clearInstanceListeners|markerclustererplus|setImagePath|getImagePath|sans|setImageExtension|66|getImageExtension|Arial|className'.split('|'),0,{})) */

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js
// ==/ClosureCompiler==

/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0
 * @author Luke Mahe
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 * <br/>
 * This is a v3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >v2 MarkerClusterer</a>.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'averageCenter': (boolean) Wether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);
  this.map_ = map;

  /**
   * @type {Array.<google.maps.Marker>}
   * @private
   */
  this.markers_ = [];

  /**
   *  @type {Array.<Cluster>}
   */
  this.clusters_ = [];

  this.sizes = [53, 56, 66, 78, 90];

  /**
   * @private
   */
  this.styles_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.ready_ = false;

  var options = opt_options || {};

  /**
   * @type {number}
   * @private
   */
  this.gridSize_ = options['gridSize'] || 60;

  /**
   * @private
   */
  this.minClusterSize_ = options['minimumClusterSize'] || 2;


  /**
   * @type {?number}
   * @private
   */
  this.maxZoom_ = options['maxZoom'] || null;

  this.styles_ = options['styles'] || [];

  /**
   * @type {string}
   * @private
   */
  this.imagePath_ = options['imagePath'] ||
      this.MARKER_CLUSTER_IMAGE_PATH_;

  /**
   * @type {string}
   * @private
   */
  this.imageExtension_ = options['imageExtension'] ||
      this.MARKER_CLUSTER_IMAGE_EXTENSION_;

  /**
   * @type {boolean}
   * @private
   */
  this.zoomOnClick_ = true;

  if (options['zoomOnClick'] != undefined) {
    this.zoomOnClick_ = options['zoomOnClick'];
  }

  /**
   * @type {boolean}
   * @private
   */
  this.averageCenter_ = false;

  if (options['averageCenter'] != undefined) {
    this.averageCenter_ = options['averageCenter'];
  }

  this.setupStyles_();

  this.setMap(map);

  /**
   * @type {number}
   * @private
   */
  this.prevZoom_ = this.map_.getZoom();

  // Add the map event listeners
  var that = this;
  google.maps.event.addListener(this.map_, 'zoom_changed', function() {
    var zoom = that.map_.getZoom();

    if (that.prevZoom_ != zoom) {
      that.prevZoom_ = zoom;
      that.resetViewport();
    }
  });

  google.maps.event.addListener(this.map_, 'idle', function() {
    that.redraw();
  });

  // Finally, add the markers
  if (opt_markers && opt_markers.length) {
    this.addMarkers(opt_markers, false);
  }
}


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =
    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +
    'images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
  this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function() {
  if (this.styles_.length) {
    return;
  }

  for (var i = 0, size; size = this.sizes[i]; i++) {
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
      height: size,
      width: size
    });
  }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }

  this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
  this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function() {
  return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function() {
  return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function() {
  return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
  return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
  return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
  var index = 0;
  var count = markers.length;
  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index
  };
};


/**
 * Set the calculator function.
 *
 * @param {function(Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
  this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function(Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function() {
  return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
  for (var i = 0, marker; marker = markers[i]; i++) {
    this.pushMarkerTo_(marker);
  }
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
  marker.isAdded = false;
  if (marker['draggable']) {
    // If the marker is draggable add a listener so we update the clusters on
    // the drag end.
    var that = this;
    google.maps.event.addListener(marker, 'dragend', function() {
      marker.isAdded = false;
      that.repaint();
    });
  }
  this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function(marker) {
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        index = i;
        break;
      }
    }
  }

  if (index == -1) {
    // Marker is not in our list of markers.
    return false;
  }

  marker.setMap(null);

  this.markers_.splice(index, 1);

  return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  } else {
   return false;
  }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
  var removed = false;

  for (var i = 0, marker; marker = markers[i]; i++) {
    var r = this.removeMarker_(marker);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function(ready) {
  if (!this.ready_) {
    this.ready_ = ready;
    this.createClusters_();
  }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
  return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function() {
  return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function(map) {
  this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
  return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(size) {
  this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function() {
  return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function(size) {
  this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
  this.resetViewport(true);

  // Set the markers a empty array.
  this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function(opt_hide) {
  // Remove all the clusters
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    cluster.remove();
  }

  // Reset the markers to not be added and to be invisible.
  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }

  this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function() {
  var oldClusters = this.clusters_.slice();
  this.clusters_.length = 0;
  this.resetViewport();
  this.redraw();

  // Remove the old clusters.
  // Do it in a timeout so the other clusters have been drawn first.
  window.setTimeout(function() {
    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
      cluster.remove();
    }
  }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function() {
  this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }

  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  var pos = marker.getPosition();
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    var center = cluster.getCenter();
    if (center) {
      var d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    var cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function() {
  if (!this.ready_) {
    return;
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
      this.map_.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      this.addToClosestCluster_(marker);
    }
  }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
  this.markerClusterer_ = markerClusterer;
  this.map_ = markerClusterer.getMap();
  this.gridSize_ = markerClusterer.getGridSize();
  this.minClusterSize_ = markerClusterer.getMinClusterSize();
  this.averageCenter_ = markerClusterer.isAverageCenter();
  this.center_ = null;
  this.markers_ = [];
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
      markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) != -1;
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function(marker) {
  if (this.isMarkerAlreadyAdded(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  var len = this.markers_.length;
  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
    // Min cluster size not reached so show the marker.
    marker.setMap(this.map_);
  }

  if (len == this.minClusterSize_) {
    // Hide the markers that were showing.
    for (var i = 0; i < len; i++) {
      this.markers_[i].setMap(null);
    }
  }

  if (len >= this.minClusterSize_) {
    marker.setMap(null);
  }

  this.updateIcon();
  return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function() {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function() {
  this.clusterIcon_.remove();
  this.markers_.length = 0;
  delete this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {number} The cluster center.
 */
Cluster.prototype.getSize = function() {
  return this.markers_.length;
};


/**
 * Returns the center of the cluster.
 *
 * @return {Array.<google.maps.Marker>} The cluster center.
 */
Cluster.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function() {
  return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function() {
  return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function() {
  var zoom = this.map_.getZoom();
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz && zoom > mz) {
    // The zoom is greater than our max zoom so show all the markers in cluster.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
      marker.setMap(this.map_);
    }
    return;
  }

  if (this.markers_.length < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.setSums(sums);
  this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.styles_ = styles;
  this.padding_ = opt_padding || 0;
  this.cluster_ = cluster;
  this.center_ = null;
  this.map_ = cluster.getMap();
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 */
ClusterIcon.prototype.triggerClusterClick = function() {
  var markerClusterer = this.cluster_.getMarkerClusterer();

  // Trigger the clusterclick event.
  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);

  if (markerClusterer.isZoomOnClick()) {
    // Zoom into the cluster.
    this.map_.fitBounds(this.cluster_.getBounds());
  }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function() {
  this.div_ = document.createElement('DIV');
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.innerHTML = this.sums_.text;
  }

  var panes = this.getPanes();
  panes.overlayMouseTarget.appendChild(this.div_);

  var that = this;
  google.maps.event.addDomListener(this.div_, 'click', function() {
    that.triggerClusterClick();
  });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= parseInt(this.width_ / 2, 10);
  pos.y -= parseInt(this.height_ / 2, 10);
  return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function() {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + 'px';
    this.div_.style.left = pos.x + 'px';
  }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function() {
  if (this.div_) {
    this.div_.style.display = 'none';
  }
  this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function() {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.style.display = '';
  }
  this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function() {
  this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function() {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function(sums) {
  this.sums_ = sums;
  this.text_ = sums.text;
  this.index_ = sums.index;
  if (this.div_) {
    this.div_.innerHTML = sums.text;
  }

  this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function() {
  var index = Math.max(0, this.sums_.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style['url'];
  this.height_ = style['height'];
  this.width_ = style['width'];
  this.textColor_ = style['textColor'];
  this.anchor_ = style['anchor'];
  this.textSize_ = style['textSize'];
  this.backgroundPosition_ = style['backgroundPosition'];
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
  this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
  var style = [];
  style.push('background-image:url(' + this.url_ + ');');
  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
  style.push('background-position:' + backgroundPosition + ';');

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  var txtColor = this.textColor_ ? this.textColor_ : 'black';
  var txtSize = this.textSize_ ? this.textSize_ : 11;

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
  return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window['MarkerClusterer'] = MarkerClusterer;
MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype['clearMarkers'] =
    MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype['fitMapToMarkers'] =
    MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype['getCalculator'] =
    MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype['getGridSize'] =
    MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype['getExtendedBounds'] =
    MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype['getTotalClusters'] =
    MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype['getTotalMarkers'] =
    MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype['removeMarker'] =
    MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype['removeMarkers'] =
    MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype['resetViewport'] =
    MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype['repaint'] =
    MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype['setCalculator'] =
    MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype['setGridSize'] =
    MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype['setMaxZoom'] =
    MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;

Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
Cluster.prototype['getSize'] = Cluster.prototype.getSize;
Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;

ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;
